package com.sqleo.common.gui;import java.awt.Color;import java.awt.Font;import javax.swing.JEditorPane;import javax.swing.JFrame;import javax.swing.JScrollPane;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;import javax.swing.text.BadLocationException;import javax.swing.text.DefaultHighlighter;import javax.swing.text.Document;import javax.swing.text.Highlighter;import javax.swing.text.JTextComponent;/*** SQLeo Visual Query Builder :: java database frontend with join definitions* Copyright (C) 2013 anudeepgade@users.sourceforge.net*  * This program is free software; you can redistribute it and/or* modify it under the terms of the GNU General Public License* as published by the Free Software Foundation; either version 2* of the License, or (at your option) any later version.* * This program is distributed in the hope that it will be useful,* but WITHOUT ANY WARRANTY; without even the implied warranty of* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the* GNU General Public License for more details.* * You should have received a copy of the GNU General Public License* along with this program; if not, write to the Free Software* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.**/public class ParenthesisMatcher implements CaretListener{	/** The tags returned from the highlighter, used for clearing the        current highlight. */	Object start, end;	/** The last highlighter used */	Highlighter highlighter;	/** Used to paint good parenthesis matches */	Highlighter.HighlightPainter goodPainter;	/** Used to paint bad parenthesis matches */	Highlighter.HighlightPainter badPainter;	/** Highlights using a good painter for matched parens, and a bad        painter for unmatched parens */	ParenthesisMatcher(Highlighter.HighlightPainter goodHighlightPainter,			Highlighter.HighlightPainter badHighlightPainter)	{		this.goodPainter = goodHighlightPainter;		this.badPainter = badHighlightPainter;	}	/** A ParenthesisMatcher with the default highlighters (green and red) */	ParenthesisMatcher()	{		this(new DefaultHighlighter.DefaultHighlightPainter(Color.green),				new DefaultHighlighter.DefaultHighlightPainter(Color.red));	}	private void clearHighlights()	{		if(highlighter != null) {			if(start != null)				highlighter.removeHighlight(start);			if(end != null)				highlighter.removeHighlight(end);			start = end = null;			highlighter = null;		}	}	/** Returns the character at position p in the document*/	private char getCharAt(Document doc, int p) throws BadLocationException	{		return doc.getText(p, 1).charAt(0);	}	/** Returns the position of the matching opening parenthesis (	 * 	 * @return the position of the matching opening paren, or -1 if none is found 	 **/	private int findMatchingOpeningParen(Document d, int paren) throws BadLocationException	{		int parenCount = 1;		int i = paren-1;		for(; i >= 0; i--) {			char c = getCharAt(d, i);			if(c == ')'){				parenCount++;			}else if(c == '('){				parenCount--;			}			if(parenCount == 0)				break;		}		return i;	}		/** Returns the position of the matching closing parenthesis )	 * 	 * @return the position of the matching closing paren, or -1 if none is found 	 **/	private  int findMatchingClosingParen(Document d, int paren) throws BadLocationException	{		int parenCount = 1;		int i = paren+1;		int totalLen = d.getLength(); 		for(; i <= totalLen ; i++) {			char c = getCharAt(d, i);			if(c == ')'){				parenCount--;			}else if(c == '('){				parenCount++;			}			if(parenCount == 0)				break;		}		return parenCount == 0 ? i : -1;	}		private  int findMatchingParen(Document d, int paren) throws BadLocationException	{		char c = getCharAt(d, paren);		if(c == ')'){			return findMatchingOpeningParen(d, paren);		}else if(c == '('){			return findMatchingClosingParen(d, paren);		}else{			return -1;		}	}	/** Called whenever the caret moves, it updates the highlights */	public void caretUpdate(CaretEvent e)	{		clearHighlights();		JTextComponent source = (JTextComponent) e.getSource();		highlighter = source.getHighlighter();		Document doc = source.getDocument();		if(e.getDot() == 0) {			return;		}		// The character we want is the one before the current position		int openOrCloseParen = e.getDot()-1;		try {			char c = getCharAt(doc, openOrCloseParen);			if(c == '(' || c == ')'){				int matchingParam = findMatchingParen(doc, openOrCloseParen);				if(matchingParam >= 0) {					char c2 = getCharAt(doc, matchingParam);					if((c2 == '(' && c == ')') ||(c2 == ')' && c == '(') ) {						start = highlighter.addHighlight(matchingParam,								matchingParam+1,								goodPainter);						end = highlighter.addHighlight(openOrCloseParen,								openOrCloseParen+1,								goodPainter);					}else {						start = highlighter.addHighlight(matchingParam,								matchingParam+1,								badPainter);						end = highlighter.addHighlight(openOrCloseParen,								openOrCloseParen+1,								badPainter);					}				}else {					end = highlighter.addHighlight(openOrCloseParen,							openOrCloseParen+1,							badPainter);						}			}		}		catch(BadLocationException ex) {			throw new Error(ex);		}	}	/** A demo main *///	public static void main(String a[])//	{//		JFrame f = new JFrame();//		JEditorPane p = new JEditorPane();//		f.getContentPane().add(new JScrollPane(p));//		p.setFont(new Font("Monospaced", 0, 12));//		p.addCaretListener(new ParenthesisMatcher());//		f.setSize(400, 400);//		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//		f.setVisible(true);//	}}